import copy
import math
from typing import List, Tuple
from  librerieTesi.diffuseRaman import core
from scipy.signal import peak_widths
import numpy as np
import  sdtfile
import matplotlib.pyplot as plt
class RawData:
    """
    This class contains the Raw measurement obtained from a .sdt file.
    """
    def __init__(
            self,
            filename: str,
            n_banks: int,
            n_basis: int,
            n_meas: int = -1,
            compress: bool = True,
            tot_banks = None,
            background_time = None):
        self.use_michele_data = False
        self.n_banks =n_banks
        self.n_basis = n_basis
        if n_meas == -1: # se non specificato è uguale a n_basis, (caso compressioni)
            self.n_meas = n_basis
        else:
            self.n_meas = n_meas
        (self.time,self.data) = self.read_sdt(filename, tot_banks)
        self.n_points = len(self.time)
        self.compress = compress
        self.accumulate()
        if background_time is not None:
            self.remove_bkg(background_time[0], background_time[1])
    def read_sdt(self, filename: str, tot_banks = None ) -> Tuple[np.array,List]:
        """
        Read the .sdt files generated by the TCSPC board and creates a list.
        """
        data = []
        for i in range(self.n_banks):
            if tot_banks:
                zeros = int(np.log10(tot_banks+1))
            else:
                zeros = int(np.log10(self.n_banks+1))
            fn = filename
            if self.n_banks == 1:
                sdt = sdtfile.SdtFile(fn+".sdt")
            elif i==0:
                sdt = sdtfile.SdtFile(fn+"_c"+'0'*(zeros)+str(i)+".sdt")
            elif i<10:
                sdt = sdtfile.SdtFile(fn+"_c"+'0'*(zeros)+str(i)+".sdt")
            elif i<100:
                sdt = sdtfile.SdtFile(fn+"_c"+'0'*(zeros-1)+str(i)+".sdt")
            elif i<1000:
                sdt = sdtfile.SdtFile(fn+"_c"+'0'*(zeros-2)+str(i)+".sdt")
            elif i<10000:
                sdt = sdtfile.SdtFile(fn+"_c"+'0'*(zeros-3)+str(i)+".sdt")
            time = sdt.times[0][:]
            batch = sdt.data[0].shape[0]
            for j in range(batch):
                data.append(sdt.data[0][ j,:])
        return (time,data)
    def accumulate(self) -> None:
        """
        From the List of measurement changes into np.array and possibily compress them.
        """
        if self.compress:
            self.tot = np.zeros((self.__len__(),self.n_points ))
            i = 0
            for el in self.data:
                idx = i%self.n_basis
                self.tot[idx,:]+= el
                i+=1
        else:
            self.tot[i,:]= np.array(self.data)
    def tot_counts(self):
        """
        Returns the total counts recorded by the TCSPC board.
        """
        return np.sum(self.tot)
    def find_idx_start(self, rel_th):
        i = 0
        th_start = rel_th * max(self.tot_time_domain())
        while self.tot_time_domain()[i]< th_start:
            i+=1
        return i
    def tot_time_domain(self):
        """
        Returns the time-domain dtof for every wavelengths.
        """
        return np.sum(self.tot, axis = 0)
    def remove_bkg(self, t_start, t_stop):
        """
        For each measurements it removes the background recorded.
        It is done before the reconstruction because it could depend on the time.
        """
        idx_start = core.time_to_idx(self.time, t_start)
        idx_stop = core.time_to_idx(self.time, t_stop)
        length = idx_stop-idx_start
        bkg = np.sum(self.tot[:,idx_start:idx_stop], axis = 1)/length
        self.tot =self.tot - bkg[:,np.newaxis]
    def cut(self, t_start, t_stop):
        """
        Selects the desired time-range.
        """
        idx_start = core.time_to_idx(self.time, t_start)
        idx_stop_approx = core.time_to_idx(self.time, t_stop)
        log_2_length = round(math.log2(idx_stop_approx- idx_start))
        length = 2**log_2_length
        
        self.time = self.time[:length]
        idx_stop = idx_start + length
        self.tot = self.tot[:,idx_start:idx_stop]
        self.n_points = length
    def t_gate_bin(self, num_t_gates):
        """
        Bins the gate into the desired number of gates.
        """
        #TODO considera che step può essere float
        time = np.zeros((num_t_gates,))
        tot = np.zeros((self.__len__(),num_t_gates))
        step = self.n_points/num_t_gates
        for i in range(num_t_gates):
            time[i] = self.time[int(i*step)]
            tot[:,i] = np.sum(self.tot[:,int(i*step):int((i+1)*step)], axis = 1)
        self.time = time
        self.tot = tot
        self.n_points = num_t_gates
    def change_um_time(self, conv):
        """
        Changes the unit of measurement of the time. It simply multiply by a constant the time.
        """
        self.time *= conv
    def dt(self):
        """
        Returns the time interval between two time steps.
        """
        return self.time[1]-self.time[0]
    def __len__(self) -> int:
        """
        returns the length of self.tot
        """
        if self.compress:
            return self.n_basis
        return len(self.data)#ho copiato tutto, cambio solo tot
    def __call__(self,i0: int, iF: int):#TODO era copy
        new = copy.copy(self)
        new.n_meas = iF-i0
        new.data = self.data[i0:iF]
        new.tot =self.tot[i0:iF,:]
        return new
    def __add__(self,b):
        return self.tot+b.tot
    def __sub__(self,b):
        return self.tot-b.tot
